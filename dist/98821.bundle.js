"use strict";(self.webpackChunkcredora_blog=self.webpackChunkcredora_blog||[]).push([[98821],{98821:(e,t,n)=>{n.r(t),n.d(t,{default:()=>u});var a=n(96540),l=n.n(a),s=n(71181),o=n(84976),c=n(42644),r=n(58027),m=n(90956);const u=()=>l().createElement(s.P.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.5},className:"max-w-4xl mx-auto p-6"},l().createElement("h1",{className:"text-3xl font-bold text-gray-800 mb-6"},"State in React"),l().createElement("section",{className:"mb-8"},l().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"What is State?"),l().createElement("p",{className:"text-gray-600 mb-4"},"State is a way to store and manage component-specific data that can change over time. Unlike props, state is private and fully controlled by the component."),l().createElement("div",{className:"bg-blue-50 border-l-4 border-blue-500 p-4 my-4"},l().createElement("p",{className:"text-blue-700"},"When state changes, React automatically re-renders the component and its children, updating the UI to reflect the new data.")),l().createElement(r.A,{language:"jsx",style:m.A,className:"rounded-lg"},"import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        Increment\n      </button>\n      <button onClick={() => setCount(count - 1)}>\n        Decrement\n      </button>\n    </div>\n  );\n}")),l().createElement("section",{className:"mb-8"},l().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"Multiple State Variables"),l().createElement("p",{className:"text-gray-600 mb-4"},"You can have as many state variables as you need in a component. Each call to useState creates an independent state variable."),l().createElement(r.A,{language:"jsx",style:m.A,className:"rounded-lg"},'function UserForm() {\n  const [name, setName] = useState(\'\');\n  const [age, setAge] = useState(0);\n  const [email, setEmail] = useState(\'\');\n\n  return (\n    <form>\n      <input\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n        placeholder="Name"\n      />\n      <input\n        type="number"\n        value={age}\n        onChange={(e) => setAge(Number(e.target.value))}\n        placeholder="Age"\n      />\n      <input\n        type="email"\n        value={email}\n        onChange={(e) => setEmail(e.target.value)}\n        placeholder="Email"\n      />\n    </form>\n  );\n}')),l().createElement("section",{className:"mb-8"},l().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"Object State"),l().createElement("p",{className:"text-gray-600 mb-4"},"When state is an object, you need to make sure to spread the previous state when updating it, as state updates are merged."),l().createElement(r.A,{language:"jsx",style:m.A,className:"rounded-lg"},'function UserProfile() {\n  const [user, setUser] = useState({\n    name: \'\',\n    age: 0,\n    email: \'\'\n  });\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setUser(prevUser => ({\n      ...prevUser,\n      [name]: value\n    }));\n  };\n\n  return (\n    <form>\n      <input\n        name="name"\n        value={user.name}\n        onChange={handleChange}\n        placeholder="Name"\n      />\n      <input\n        name="age"\n        type="number"\n        value={user.age}\n        onChange={handleChange}\n        placeholder="Age"\n      />\n      <input\n        name="email"\n        type="email"\n        value={user.email}\n        onChange={handleChange}\n        placeholder="Email"\n      />\n    </form>\n  );\n}')),l().createElement("section",{className:"mb-8"},l().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"State Updates"),l().createElement("p",{className:"text-gray-600 mb-4"},"State updates may be asynchronous, so you shouldn't rely on previous state values directly. Instead, use the functional update form when the new state depends on the previous state."),l().createElement(r.A,{language:"jsx",style:m.A,className:"rounded-lg"},"function Counter() {\n  const [count, setCount] = useState(0);\n\n  // Wrong way - may not work as expected\n  const wrongIncrement = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n  };\n\n  // Correct way - using functional updates\n  const correctIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={correctIncrement}>\n        Increment Twice\n      </button>\n    </div>\n  );\n}")),l().createElement("section",{className:"mb-8"},l().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"Derived State"),l().createElement("p",{className:"text-gray-600 mb-4"},"Some values can be calculated directly from state instead of being stored as state themselves. This is called derived state."),l().createElement(r.A,{language:"jsx",style:m.A,className:"rounded-lg"},"function TodoList() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: 'Learn React', completed: false },\n    { id: 2, text: 'Build an app', completed: true }\n  ]);\n\n  // Derived state - calculated from existing state\n  const completedTodos = todos.filter(todo => todo.completed);\n  const incompleteTodos = todos.filter(todo => !todo.completed);\n  const totalTodos = todos.length;\n\n  return (\n    <div>\n      <h2>Todo Stats</h2>\n      <p>Total: {totalTodos}</p>\n      <p>Completed: {completedTodos.length}</p>\n      <p>Remaining: {incompleteTodos.length}</p>\n    </div>\n  );\n}")),l().createElement("section",{className:"mb-8"},l().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"State Best Practices"),l().createElement("div",{className:"bg-white shadow-md rounded-lg p-6"},l().createElement("ul",{className:"list-disc list-inside space-y-3 text-gray-600"},l().createElement("li",null,"Keep state minimal - don't store what you can compute"),l().createElement("li",null,"Avoid redundant state - derive values when possible"),l().createElement("li",null,"Use multiple state variables for unrelated state"),l().createElement("li",null,"Use a single state object for related state"),l().createElement("li",null,"Always use the functional update form when new state depends on old state"),l().createElement("li",null,"Don't modify state directly - always use setState"),l().createElement("li",null,"Keep state as local as possible")))),l().createElement("div",{className:"bg-blue-50 border-l-4 border-blue-500 p-4 my-8"},l().createElement("h3",{className:"text-lg font-semibold text-blue-800 mb-2"},"Pro Tips"),l().createElement("ul",{className:"list-disc list-inside space-y-2 text-blue-700"},l().createElement("li",null,"Consider using useReducer for complex state logic"),l().createElement("li",null,"Use context for state that needs to be accessed by many components"),l().createElement("li",null,"Break down complex state into smaller, manageable pieces"),l().createElement("li",null,"Use TypeScript to catch state-related bugs early"))),l().createElement("div",{className:"mt-12 flex justify-between items-center"},l().createElement(o.N_,{to:"/react-course/props",className:"text-blue-600 hover:text-blue-800 flex items-center"},l().createElement(c.aze,{className:"mr-2"})," Previous: Props"),l().createElement(o.N_,{to:"/react-course/events",className:"bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center"},"Next: Events ",l().createElement(c.PjK,{className:"ml-2"}))))}}]);