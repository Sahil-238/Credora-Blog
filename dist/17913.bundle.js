"use strict";(self.webpackChunkcredora_blog=self.webpackChunkcredora_blog||[]).push([[17913],{17913:(e,t,n)=>{n.r(t),n.d(t,{default:()=>s});var a=n(96540),o=n.n(a),r=n(71181),l=n(84976);const s=()=>o().createElement(r.P.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.5},className:"max-w-4xl mx-auto p-6"},o().createElement("h1",{className:"text-3xl font-bold text-gray-800 mb-6"},"React.memo"),o().createElement("section",{className:"mb-8"},o().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"What is React.memo?"),o().createElement("p",{className:"text-gray-600 mb-4"},o().createElement("code",null,"React.memo")," is a higher-order component that memoizes a functional component. It prevents unnecessary re-renders by performing a shallow comparison of the component’s props. If the props haven’t changed, React skips rendering the component and reuses the last rendered output.")),o().createElement("section",{className:"mb-8"},o().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"Why use React.memo?"),o().createElement("ul",{className:"list-disc list-inside text-gray-600 mb-4"},o().createElement("li",null,"Optimizes functional components that render often with unchanged props."),o().createElement("li",null,"Improves performance by reducing unnecessary DOM updates."),o().createElement("li",null,"Useful when passing components as children or in large lists."))),o().createElement("section",{className:"mb-8"},o().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"How React.memo works"),o().createElement("p",{className:"text-gray-600 mb-4"},"React.memo performs a shallow comparison of the previous and new props. If all props are equal (===), the component will not re-render. For complex prop comparisons, you can provide a custom comparison function as the second argument.")),o().createElement("section",{className:"mb-8"},o().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"Basic Example"),o().createElement("p",{className:"text-gray-600 mb-4"},"Here is a simple example demonstrating how React.memo prevents unnecessary re-renders:"),o().createElement("pre",{className:"bg-gray-100 p-4 rounded-lg overflow-auto mb-4"},"\nimport React, { useState } from 'react';\n\nconst Child = React.memo(({ count }) => {\n  console.log('Child rendered');\n  return <div>Count: {count}</div>;\n});\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [toggle, setToggle] = useState(false);\n\n  return (\n    <div>\n      <Child count={count} />\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <button onClick={() => setToggle(!toggle)}>Toggle State</button>\n    </div>\n  );\n}\n\nexport default App;\n"),o().createElement("p",{className:"text-gray-600 mb-4"},"In this example:",o().createElement("ul",{className:"list-disc list-inside ml-6"},o().createElement("li",null,"The ",o().createElement("code",null,"Child")," component only re-renders when the ",o().createElement("code",null,"count")," prop changes."),o().createElement("li",null,'Clicking "Toggle State" does not cause the ',o().createElement("code",null,"Child")," to re-render because its props remain the same."),o().createElement("li",null,'You can see "Child rendered" logged only when necessary.')))),o().createElement("section",{className:"mb-8"},o().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"Using a custom comparison function"),o().createElement("p",{className:"text-gray-600 mb-4"},"By default, React.memo uses a shallow comparison. You can provide a custom ",o().createElement("code",null,"areEqual")," function to control how props are compared:"),o().createElement("pre",{className:"bg-gray-100 p-4 rounded-lg overflow-auto mb-4"},"\nconst Child = React.memo(\n  ({ user }) => {\n    console.log('Child rendered');\n    return <div>{user.name}</div>;\n  },\n  (prevProps, nextProps) => {\n    // return true to skip re-render\n    return prevProps.user.id === nextProps.user.id;\n  }\n);\n"),o().createElement("p",{className:"text-gray-600 mb-4"},"In this example, the component only re-renders if the ",o().createElement("code",null,"user.id")," changes, ignoring other property changes.")),o().createElement("section",{className:"mb-8"},o().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"When NOT to use React.memo"),o().createElement("ul",{className:"list-disc list-inside text-gray-600"},o().createElement("li",null,"For components that rarely re-render or have simple render logic."),o().createElement("li",null,"When prop comparison is expensive and outweighs the rendering cost."),o().createElement("li",null,"If your props are frequently new objects or functions, causing memoization to fail."))),o().createElement("div",{className:"mt-12 flex justify-between items-center"},o().createElement(l.N_,{to:"/react-course/optimization",className:"text-blue-600 hover:text-blue-800"},"← Previous"),o().createElement(l.N_,{to:"/react-course/lazy-loading",className:"bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors"},"Next →")))}}]);