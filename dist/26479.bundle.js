"use strict";(self.webpackChunkcredora_blog=self.webpackChunkcredora_blog||[]).push([[26479],{26479:(e,t,n)=>{n.r(t),n.d(t,{default:()=>m});var a=n(96540),s=n.n(a),r=n(71181),o=n(84976),l=n(42644),c=n(58027),u=n(90956);const m=()=>s().createElement(r.P.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.5},className:"max-w-4xl mx-auto p-6"},s().createElement("h1",{className:"text-3xl font-bold text-gray-800 mb-6"},"Basic React Hooks"),s().createElement("section",{className:"mb-8"},s().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"Understanding Hooks"),s().createElement("p",{className:"text-gray-600 mb-4"},'Hooks are functions that allow you to "hook into" React state and lifecycle features from function components. They let you use state and other React features without writing a class.'),s().createElement("div",{className:"grid grid-cols-1 md:grid-cols-3 gap-4"},s().createElement("div",{className:"bg-white p-4 rounded-lg shadow"},s().createElement(l.jTZ,{className:"text-2xl text-blue-600 mb-2"}),s().createElement("h3",{className:"text-lg font-semibold text-gray-700 mb-2"},"State"),s().createElement("p",{className:"text-gray-600"},"Manage component state")),s().createElement("div",{className:"bg-white p-4 rounded-lg shadow"},s().createElement(l.Hbo,{className:"text-2xl text-blue-600 mb-2"}),s().createElement("h3",{className:"text-lg font-semibold text-gray-700 mb-2"},"Effect"),s().createElement("p",{className:"text-gray-600"},"Handle side effects")),s().createElement("div",{className:"bg-white p-4 rounded-lg shadow"},s().createElement(l.PjK,{className:"text-2xl text-blue-600 mb-2"}),s().createElement("h3",{className:"text-lg font-semibold text-gray-700 mb-2"},"Context"),s().createElement("p",{className:"text-gray-600"},"Share data between components")))),s().createElement("section",{className:"mb-8"},s().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"useState Hook"),s().createElement("p",{className:"text-gray-600 mb-4"},"The useState hook lets you add state to functional components. It returns an array with the current state value and a function to update it."),s().createElement(c.A,{language:"jsx",style:u.A,className:"rounded-lg"},"// useState Hook\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n}\n\n// useState with object\nfunction UserForm() {\n  const [user, setUser] = useState({\n    name: '',\n    email: '',\n    age: ''\n  });\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setUser(prevUser => ({\n      ...prevUser,\n      [name]: value\n    }));\n  };\n\n  return (\n    <form>\n      <input\n        name=\"name\"\n        value={user.name}\n        onChange={handleChange}\n      />\n      <input\n        name=\"email\"\n        value={user.email}\n        onChange={handleChange}\n      />\n      <input\n        name=\"age\"\n        value={user.age}\n        onChange={handleChange}\n      />\n    </form>\n  );\n}")),s().createElement("section",{className:"mb-8"},s().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"useEffect Hook"),s().createElement("p",{className:"text-gray-600 mb-4"},"The useEffect hook lets you perform side effects in function components. It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount in React classes."),s().createElement(c.A,{language:"jsx",style:u.A,className:"rounded-lg"},"// useEffect Hook\nimport React, { useState, useEffect } from 'react';\n\n// Basic effect\nfunction Timer() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setSeconds(s => s + 1);\n    }, 1000);\n\n    // Cleanup function\n    return () => clearInterval(interval);\n  }, []); // Empty dependency array\n\n  return <div>Seconds: {seconds}</div>;\n}\n\n// Data fetching\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchUser = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(\n          `/api/users/${userId}`\n        );\n        const data = await response.json();\n        setUser(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUser();\n  }, [userId]); // Dependency array with userId\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!user) return null;\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}")),s().createElement("section",{className:"mb-8"},s().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"useRef Hook"),s().createElement("p",{className:"text-gray-600 mb-4"},"The useRef hook creates a mutable ref object that persists for the full lifetime of the component. It's commonly used to access DOM elements directly."),s().createElement(c.A,{language:"jsx",style:u.A,className:"rounded-lg"},"// useRef Hook\nimport React, { useRef, useEffect } from 'react';\n\n// DOM reference\nfunction AutoFocusInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    inputRef.current.focus();\n  }, []);\n\n  return <input ref={inputRef} />;\n}\n\n// Previous value reference\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const prevCountRef = useRef();\n\n  useEffect(() => {\n    prevCountRef.current = count;\n  }, [count]);\n\n  return (\n    <div>\n      <p>Current: {count}</p>\n      <p>Previous: {prevCountRef.current}</p>\n      <button onClick={() => setCount(c => c + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n}\n\n// Mutable value reference\nfunction StopWatch() {\n  const [time, setTime] = useState(0);\n  const intervalRef = useRef(null);\n\n  const start = () => {\n    if (intervalRef.current !== null) return;\n    intervalRef.current = setInterval(() => {\n      setTime(t => t + 1);\n    }, 1000);\n  };\n\n  const stop = () => {\n    if (intervalRef.current === null) return;\n    clearInterval(intervalRef.current);\n    intervalRef.current = null;\n  };\n\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current !== null) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []);\n\n  return (\n    <div>\n      <p>Time: {time}s</p>\n      <button onClick={start}>Start</button>\n      <button onClick={stop}>Stop</button>\n    </div>\n  );\n}")),s().createElement("section",{className:"mb-8"},s().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"useContext Hook"),s().createElement("p",{className:"text-gray-600 mb-4"},"The useContext hook subscribes to React context without introducing nesting. It's used for consuming context that was created by a parent Provider component."),s().createElement(c.A,{language:"jsx",style:u.A,className:"rounded-lg"},"// useContext Hook\nimport React, { createContext, useContext, useState } from 'react';\n\n// Create context\nconst ThemeContext = createContext(null);\n\n// Provider component\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(t => t === 'light' ? 'dark' : 'light');\n  };\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// Consumer component\nfunction ThemedButton() {\n  const { theme, toggleTheme } = useContext(ThemeContext);\n\n  return (\n    <button\n      className={`btn-${theme}`}\n      onClick={toggleTheme}\n    >\n      Current theme: {theme}\n    </button>\n  );\n}\n\n// Usage\nfunction App() {\n  return (\n    <ThemeProvider>\n      <div>\n        <h1>Themed App</h1>\n        <ThemedButton />\n      </div>\n    </ThemeProvider>\n  );\n}")),s().createElement("section",{className:"mb-8"},s().createElement("h2",{className:"text-2xl font-semibold text-gray-700 mb-4"},"Hooks Best Practices"),s().createElement("div",{className:"bg-white shadow-md rounded-lg p-6"},s().createElement("ul",{className:"list-disc list-inside space-y-3 text-gray-600"},s().createElement("li",null,"Only call Hooks at the top level"),s().createElement("li",null,"Only call Hooks from React function components"),s().createElement("li",null,"Use multiple useState calls for unrelated state"),s().createElement("li",null,"Keep effects focused on one concern"),s().createElement("li",null,"Always include all dependencies in useEffect"),s().createElement("li",null,"Clean up side effects when necessary"),s().createElement("li",null,"Use custom hooks for reusable logic")))),s().createElement("div",{className:"bg-blue-50 border-l-4 border-blue-500 p-4 my-8"},s().createElement("h3",{className:"text-lg font-semibold text-blue-800 mb-2"},"Pro Tips"),s().createElement("ul",{className:"list-disc list-inside space-y-2 text-blue-700"},s().createElement("li",null,"Use the ESLint plugin for Hooks"),s().createElement("li",null,"Extract complex state logic into reducers"),s().createElement("li",null,"Consider memoization for expensive calculations"),s().createElement("li",null,"Use custom hooks for shared logic"))),s().createElement("div",{className:"mt-12 flex justify-between items-center"},s().createElement(o.N_,{to:"/react-course/advanced-routing",className:"text-blue-600 hover:text-blue-800 flex items-center"},s().createElement(l.PjK,{className:"mr-2"})," Previous: Advanced Routing"),s().createElement(o.N_,{to:"/react-course/custom-hooks",className:"bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center"},"Next: Custom Hooks ",s().createElement(l.PjK,{className:"ml-2"}))))}}]);